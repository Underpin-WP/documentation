"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[261],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var o=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,l=function(e,t){if(null==e)return{};var n,o,l={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=o.createContext({}),a=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=a(e.components);return o.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,m=c(e,["components","mdxType","originalType","parentName"]),p=a(n),d=l,g=p["".concat(s,".").concat(d)]||p[d]||u[d]||i;return n?o.createElement(g,r(r({ref:t},m),{},{components:n})):o.createElement(g,r({ref:t},m))}));function d(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=n.length,r=new Array(i);r[0]=p;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:l,r[1]=c;for(var a=2;a<i;a++)r[a]=n[a];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},873:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>c,toc:()=>a});var o=n(7462),l=(n(7294),n(3905));const i={},r="Immutable Collection",c={unversionedId:"reference/registries/object-registries/collections/immutable-collection",id:"reference/registries/object-registries/collections/immutable-collection",title:"Immutable Collection",description:"ImmutableCollection is a Collection in which items cannot be added or removed after the items have been locked. Note this does **not** mean that the values of the items the registry holds are immutable. If an immutable collection contains objects with public setters, those items will still update. All this does is prevent you from adding new_ items to this registry once it's set-up.",source:"@site/docs/reference/registries/object-registries/collections/immutable-collection.md",sourceDirName:"reference/registries/object-registries/collections",slug:"/reference/registries/object-registries/collections/immutable-collection",permalink:"/reference/registries/object-registries/collections/immutable-collection",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Collections",permalink:"/reference/registries/object-registries/collections/"},next:{title:"Mutable Collection With Remove",permalink:"/reference/registries/object-registries/collections/mutable-collection-with-remove"}},s={},a=[{value:"Locking The Collection",id:"locking-the-collection",level:2},{value:"Special Handling of Seed",id:"special-handling-of-seed",level:2}],m={toc:a};function u(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"immutable-collection"},"Immutable Collection"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Immutable_Collection")," is a ",(0,l.kt)("a",{parentName:"p",href:"./"},"Collection")," in which items cannot be added or removed after the items have been locked. Note this does ",(0,l.kt)("strong",{parentName:"p"},"not")," mean that the values of the items the registry holds are immutable. If an immutable collection contains objects with public setters, those items will still update. All this does is prevent you from adding ",(0,l.kt)("em",{parentName:"p"},"new")," items to this registry once it's set-up."),(0,l.kt)("h2",{id:"locking-the-collection"},"Locking The Collection"),(0,l.kt)("p",null,"The thing that makes an Immutable Collection different from a ",(0,l.kt)("a",{parentName:"p",href:"./mutable-collection"},"Mutable Collection")," is its ability to lock the collection, making it impossible to add or remove items from the collection after it is locked. This is done using ",(0,l.kt)("inlineCode",{parentName:"p"},"Immutable_Collection::lock")," once you're done adding items."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-php"},"class Blog_Post {\n  /*...*/\n}\n\n$immutable_collection = \\Underpin\\Registries\\Immutable_Collection::make(Blog_Post::class);\n\n// Adds the new blog post to the collection.\n$immutable_collection->add('blog_post_1',new Blog_Post());\n\n// Locks the collection, making it no-longer possible to mutate.\n$immutable_collection->lock();\n\n// Throws exception because the collection is locked.\n$immutable_collection->add('blog_post_2',new Blog_Post());\n")),(0,l.kt)("p",null,"Once a collection is locked, it cannot be unlocked. However, you ",(0,l.kt)("em",{parentName:"p"},"can")," merge items from the existing collection into a new collection instance."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-php"},"class Blog_Post {\n  /*...*/\n}\n\n$immutable_collection = \\Underpin\\Registries\\Immutable_Collection::make(Blog_Post::class);\n\n// Adds the new blog post to the collection.\n$immutable_collection->add('blog_post_1',new Blog_Post());\n\n// Locks the collection, making it no-longer possible to mutate.\n$immutable_collection->lock();\n\n// Creates a new collection\n$new_collection = \\Underpin\\Registries\\Immutable_Collection::make(Blog_Post::class);\n\n// Adds items from the original collection to the new collection.\n$new_collection->merge($new_collection, $immutable_collection);\n\n// Lock the new collection\n$new_collection->lock();\n")),(0,l.kt)("h2",{id:"special-handling-of-seed"},"Special Handling of Seed"),(0,l.kt)("p",null,"Immutable Collections support seeding just like any other ",(0,l.kt)("a",{parentName:"p",href:"../../#seed"},"Registry"),", however, once the registry has finished adding the items to the registry, it automatically locks the items. After this, no more items can be added."),(0,l.kt)("p",null,"This means that if you want to add items to your registry and lock it programmatically, you must use ",(0,l.kt)("inlineCode",{parentName:"p"},"Immutable_Collection::add")," and then manually lock the registry using ",(0,l.kt)("inlineCode",{parentName:"p"},"Immutable_Collection::lock"),", as detailed above."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-php"},"use \\Underpin\\Registries\\Immutable_Collection;\nuse \\Underpin\\Interfaces\\Identifiable_Int;\nclass Blog_Post implements Identifiable_Int {\n  /*...*/\n}\n\n// Adds the listed items to the collection, and locks the collection.\n$blog_posts = Immutable_Collection::make(Blog_Post::class)->seed([\n  new Blog_Post(/*...*/),\n  new Blog_Post(/*...*/),\n  new Blog_Post(/*...*/),\n  new Blog_Post(/*...*/),\n  new Blog_Post(/*...*/),\n]);\n\n$post = new Blog_Post();\n\n// This would throw an exception because items cannot be added to the collection after seeding.\n$blog_posts->add($post->get_id(), $post);\n")))}u.isMDXComponent=!0}}]);